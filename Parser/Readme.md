# ðŸ§¾ Parser â€“ Syntax-e-Urdu

This module implements the **Syntax Parser** for the `Syntax-e-Urdu` compiler frontend. It takes tokenized output from the lexer and builds a **parse tree** using a **Context-Free Grammar (CFG)** defined for Urdu-inspired constructs like `Agar`, `Wagarna`, and `Adadi`.

## ðŸ§© Purpose

The parser ensures that token sequences generated by the lexer follow the correct grammatical structure. It checks whether the code forms valid control structures, declarations, and expressions â€” all written in an Urdu-style syntax.

## ðŸ§  How It Works

1. Loads token stream (from the lexer)
2. Matches tokens against grammar rules defined in `grammar.txt`
3. Applies top-down parsing (LL parser or recursive descent)
4. Records each production used to construct the parse tree
5. Logs success or syntax errors to `parse_log.txt`

## âš™ï¸ Features

- Custom **CFG** for Urdu-style code
- Implements a **recursive descent parser**
- Handles:
  - `Agar` / `Wagarna` conditionals
  - `JabTak` loops
  - `Adadi`, `Kirdar`, and variable declarations
  - Arithmetic and logical expressions
- Logs parse steps, production usage, and errors
- Modular design for easy rule extensions

## ðŸ§¾ Example Grammar Snippet

```text
S â†’ Agar (E) { S } Wagarna { S }
E â†’ id relop id
relop â†’ == | > | < | >= | <=
```

## ðŸ“ Files in This Module

1. parser.cpp          
2. grammar.txt          
3. tokens.txt          
4. parse_log.txt        


## ðŸ“Œ Notes
- Parser is fully independent of lexer internals â€” it only needs the token stream.
- Designed to mimic human-readable Urdu logic structures.
- Easily extendable to support more statements or control flow types.
