# 🧾 Parser – Syntax-e-Urdu

This module implements the **Syntax Parser** for the `Syntax-e-Urdu` compiler frontend. It takes tokenized output from the lexer and builds a **parse tree** using a **Context-Free Grammar (CFG)** defined for Urdu-inspired constructs like `Agar`, `Wagarna`, and `Adadi`.

## 🧩 Purpose

The parser ensures that token sequences generated by the lexer follow the correct grammatical structure. It checks whether the code forms valid control structures, declarations, and expressions — all written in an Urdu-style syntax.

## 🧠 How It Works

1. Loads token stream (from the lexer)
2. Matches tokens against grammar rules defined in `grammar.txt`
3. Applies top-down parsing (LL parser or recursive descent)
4. Records each production used to construct the parse tree
5. Logs success or syntax errors to `parse_log.txt`

## ⚙️ Features

- Custom **CFG** for Urdu-style code
- Implements a **recursive descent parser**
- Handles:
  - `Agar` / `Wagarna` conditionals
  - `JabTak` loops
  - `Adadi`, `Kirdar`, and variable declarations
  - Arithmetic and logical expressions
- Logs parse steps, production usage, and errors
- Modular design for easy rule extensions

## 🧾 Example Grammar Snippet

```text
S → Agar (E) { S } Wagarna { S }
E → id relop id
relop → == | > | < | >= | <=
```

## 📁 Files in This Module

parser/
├── parser.cpp         # Parser implementation
├── grammar.txt        # CFG rules (read by the parser)
├── tokens.txt         # Token stream from the lexer
├── parse_log.txt      # Output: parse tree steps and errors


## 📌 Notes
- Parser is fully independent of lexer internals — it only needs the token stream.
- Designed to mimic human-readable Urdu logic structures.
- Easily extendable to support more statements or control flow types.
